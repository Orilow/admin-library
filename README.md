# Library API

RESTful API для управления библиотечным каталогом: книги, читатели, выдача/возврат книг, аутентификация библиотекарей.

## Описание проекта

Library API позволяет:

- Управлять книгами (CRUD, публичный доступ к `GET /books`).
- Управлять читателями (имя, уникальный email).
- Регистрировать выдачу/возврат книг с лимитом 3 книги на читателя.
- Аутентифицировать библиотекарей через JWT (`POST /register`, `POST /login`).
- Поддерживать пагинацию (`skip`, `limit`) и описание книг (`description`).

API разработан с акцентом на безопасность, тестируемость и автоматизацию деплоя.

## Структура проекта

```
├── alembic/              # Миграции БД (Alembic)
├── alembic.ini           # Конфигурация Alembic
├── src/                  # Основной код
│   ├── auth.py           # Аутентификация (JWT, get_current_user)
│   ├── database.py       # Настройка SQLAlchemy (DATABASE_URL)
│   ├── main.py           # FastAPI приложение, эндпоинты
│   ├── models.py         # SQLAlchemy модели (BookModel, UserModel)
│   ├── schemas.py        # Pydantic схемы (BookSchema, UserCreateSchema)
│   └── seed.py           # Скрипт для сидирования данных
├── tests/                # Тесты
│   ├── conftest.py       # Pytest фикстуры (test_user, test_book)
│   └── test_books.py     # Тесты для книг
├── .env                  # Переменные окружения (DATABASE_URL, JWT_SECRET_KEY)
├── requirements.txt      # Зависимости
└── README.md             # Документация
```

- `src/`: Логика API, разделённая на модули (аутентификация, модели, схемы).
- `tests/`: Изолированные тесты с фикстурами.
- `alembic/`: Миграции для таблиц и `description`.
- `.env`: Хранит `DATABASE_URL_LOCAL`, `DATABASE_URL_PROD`, `JWT_SECRET_KEY`.

## Инструкция по запуску

1. **Установка зависимостей**:

```bash
pip install -r requirements.txt
```

2. **Настройка** .env, прокиньте свои переменные :

```bash
echo "DATABASE_URL_LOCAL=postgresql://ilya@localhost:5432/library" >> .env
echo "DATABASE_URL_PROD=postgresql://ilya@localhost:5432/library_prod" >> .env
echo "JWT_SECRET_KEY=$(openssl rand -hex 32)" >> .env
```

4. **Запуск сервера**:

```bash
fastapi dev src/main.py
```

- Миграции применяются автоматически при старте.
- API доступен на http://127.0.0.1:8000/docs.

5. **Регистрация первого пользователя**:

- Открой http://127.0.0.1:8000/docs.
- Выполни POST /register с телом:

```json
{
  "email": "admin@library.com",
  "password": "adminpass"
}
```

- Получи токен через POST /login:

```json
{
  "email": "admin@library.com",
  "password": "adminpass"
}
```

- Используй токен (Bearer &lt;token&gt;) для защищённых эндпоинтов.

6. **Сидирование данных**:

```bash
export DATABASE_URL=$(grep DATABASE_URL_LOCAL .env | cut -d '=' -f2)
python -m src.seed
```

- Добавляет 15 книг, 15 читателей, 10 займов, 2 библиотекаря.

## Решения по структуре БД

**Таблицы**:

1. `users`:
   - Поля: `id` (PK), `email` (уникальный, индекс), `password` (хешированный).
   - Назначение: Хранение библиотекарей для аутентификации.
   - Решение: Уникальный `email` для предотвращения дубликатов, индекс для быстрого поиска.
2. `books`:
   - Поля: `id` (PK), `title`, `author`, `year_published` (опционально), `isbn` (опционально), `copies_available`, `description`.
   - Назначение: Хранение книг.
   - Решение: `description` добавлено миграцией с дефолтным значением для существующих записей. `isbn` и `year_published` опциональны для гибкости.
3. `readers`:
   - Поля: `id` (PK), `name`, `email` (уникальный, индекс).
   - Назначение: Хранение читателей.
   - Решение: Уникальный `email` для идентификации.
4. `borrowed_books`:
   - Поля: `id` (PK), `book_id` (FK), `reader_id` (FK), `borrow_date`, `return_date` (опционально).
   - Назначение: Регистрация займов.
   - Решение: Внешние ключи (`book_id`, `reader_id`) без каскадного удаления, так как книги/читатели не удаляются при возврате.

> В общем структуры заложенной в ТЗ оказалось достаточно для реализации. borrowed_books как таблица связности между readers и books (многие ко многим) пока хватает для удовлетворения требований.

**Сложности**:

- **Миграция** `description`: Нужно было добавить поле для существующих записей. Решение: Миграция с `op.execute` для установки дефолтного значения.
- **Уникальность** `email`: Обеспечена через `unique=True` и индексы.
- **Тестовая БД**: Изначально тесты ломались из-за использования `library` вместо `test_library`. Решение: Изоляция через `conftest.py`.

## Сложности Бизнес-логика (пункты 4.1, 4.2, 4.3)

### 4.1: Регистрация выдачи книги (`POST /rent_book`)

- **Сложности**:

  - Изначально хотелось одним запросом делать попытку изменения таблицы и опираться на constraints, но это оказалось не так информативно как хотелось бы, поэтому приходится делать доп запросы заранее (а есть ли юзер, а книга).

  - Возможна выдача одной копии книги двум читателям. Решение: Использовал транзакцию для атомарности.

  - **Лимит**: Изначально не учитывали возвращённые книги. Решение: Фильтр `return_date is null`.

### 4.2: Возврат книги (`POST /return_book`)

- **Сложности**:
  - **Неправильный возврат**: Пытались вернуть не выданную книгу. Решение: Проверка `return_date is null`.
  - **Тесты**: Изначально падали из-за отсутствия фикстур. Решение: Добавили `test_reader` и `test_book`.

### 4.3: Лимит в 3 книги на читателя

- **Сложности**:
  - **Тесты**: Падали из-за неправильной БД (`library` вместо `test_library`). Решение: Исправили `conftest.py`.

**Общие сложности**:

- **403 вместо 401**: `HTTPBearer` возвращал 403 для неавторизованных запросов. Решение: `auto_error=False` и проверка `credentials is None`.
- **Сессии в тестах**: Тесты ломались из-за переиспользования сессий. Решение: `TestingSessionLocal` и `db.rollback()` в фикстурах.

## Реализация аутентификации

- **Как работает**:
  - Пользователи регистрируются через `POST /register` (`email`, `password`).
  - Пароль хешируется с помощью `bcrypt` (`passlib`).
  - При логине (`POST /login`) генерируется JWT-токен с `email` в `sub` (`python-jose`).
  - Токен проверяется в `get_current_user` через `jwt.decode` и поиск пользователя в `users`.
- **Генерация токенов**:
  - `create_access_token`: Создаёт JWT с `sub=email`, `exp` (30 минут), подписывает `HS256` с `JWT_SECRET_KEY`.
- **Проверка токенов**:
  - `get_current_user`: Извлекает токен через `HTTPBearer`, декодирует, проверяет `email` в БД.
  - Ошибки: 401 для отсутствия/невалидного токена или пользователя.
- **Защищённые эндпоинты**:
  - Все, кроме `GET /books` и `GET /books/{id}`.
  - Причина: Только библиотекари могут управлять книгами, читателями, займами.
  - **Причина открытого** `GET /books `: "Открытие" зависит от того, где используется ручка, что за проект. В данном случае это админка для библиотекарей. Я предположил, что это приложение - будет монолит как для админки, так и для публички. Потому что на ранних этапах - глупо сразу делать разные, MVP будет быстрее на монолите сделать. Ну если это только не закрытая библиотека для ФСБшников - там не надо светить книгами напоказ (только если во внутренней сети)
  - Защита через `Depends(get_current_user)` в эндпоинтах.
- **Библиотеки**:
  - `python-jose`: Для JWT (надёжный, поддерживает `HS256`).
  - `passlib[bcrypt]`: Для хеширования паролей (безопасный алгоритм).
  - **Почему**: Стандартные библиотеки для FastAPI, минимальная настройка, высокая безопасность.
- **Сложности**:
  - **403 вместо 401**: Исправлено через `auto_error=False` в `HTTPBearer`.
  - **Тесты**: Падали из-за отсутствия токена. Решение: Фикстура `test_user` и логин в тестах.

## 

## Тестирование

1. **Создай тестовую базу**:

```bash
createdb test_library
```

2. **Запусти тесты**:

```bash
pytest -v
```

- Тесты используют `test_library` и фикстуры (`test_user`, `test_book`).
- Покрывают авторизацию, CRUD, займы.

3. **Форматирование и линтинг**:

```bash
black src/
flake8 src/ --max-line-length=79
```

## Деплой на Render Free Tier

1. Создай аккаунт на render.com.

2. Создай PostgreSQL базу:

   - **New** → **PostgreSQL**.
   - Name: `library-db`, Instance Type: **Free**.
   - Скопируй **External Database URL**.

3. Создай Web Service:

   - **New** → **Web Service**.
   - Подключи GitHub репозиторий.
   - Name: `library-api`, Instance Type: **Free**.
   - Build Command: `pip install -r requirements.txt`.
   - Start Command: `uvicorn src.main:app --host 0.0.0.0 --port $PORT`.
   - Environment Variables:
     - `DATABASE_URL`: **External Database URL**.
     - `JWT_SECRET_KEY`: Сгенерируй (`openssl rand -hex 32`).

4. Деплой

5. Проверь API:

   - URL: `https://library-api.onrender.com/docs`.
   - Зарегистрируй пользователя (`POST /register`).
   - Получи токен (`POST /login`).

**Ограничения Render Free Tier**:

- Засыпание через 15 минут.
- PostgreSQL истекает через 90 дней.
- Ограниченные ресурсы.

## Творческая часть: Предложенная фича

**Фича**: Поиск книг по заголовку или описанию. Ниже рассмотрим ее, но можно еще сделать лист ожидания на книгу (если большая аудитория, то имеет смысл), чтобы потом оповещать о доступности и тд

- **Описание**:  Даже после 30 книг уже тяжело станет искать глазами. Добавить эндпоинт `GET /books?search=<query>` для поиска книг, где `query` содержится в `title` или `description`. Поддерживать пагинацию (`skip`, `limit`). 
- **Зачем**: Упрощает поиск в большом каталоге, улучшает UX.
- **Реализация (идея)**:
  - Добавить параметр `search: Optional[str]` в `GET /books`.
  - Использовать SQLAlchemy: `BookModel.title.ilike(f"%{query}%") | BookModel.description.ilike(f"%{query}%")`.
  - Сохранить пагинацию: `.offset(skip).limit(limit)`.
  - Добавить индекс на `title` и `description` для производительности.
  - Тесты: Проверить поиск по `title`, `description`, пустой запрос.
- **Преимущества**: Простая реализация, высокая ценность для пользователей.